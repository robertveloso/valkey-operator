name: CI/CD

on:
  pull_request:
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - 'Dockerfile.*'
      - 'Makefile'
      - '.github/workflows/**'
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  VALKEY_VERSION: 9.0.1

# Default permissions (can be overridden per job)
# Note: packages: read is included by default as most jobs need to read from GHCR
# Individual jobs override this when they need write access or additional permissions
permissions:
  contents: read
  packages: read
  actions: read

jobs:
  # ============================================
  # PR Workflow: Fast feedback (amd64 only)
  # ============================================

  lint:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: 1.25
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v9
        with:
          version: v2.4.0
          args: --timeout=5m --config=.golangci.yml

  hadolint:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    strategy:
      matrix:
        dockerfile: [Dockerfile.controller, Dockerfile.sidecar]
    steps:
      - uses: actions/checkout@v6
      - uses: hadolint/hadolint-action@v3.3.0
        with:
          dockerfile: ${{ matrix.dockerfile }}

  gosec:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v6
      - name: Security Scan
        uses: securego/gosec@master
        with:
          args: '-fmt sarif -out results.sarif ./...'
      - name: Upload SARIF file
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: results.sarif

  build-binaries-pr:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: 1.25
      - name: Install build dependencies
        run: |
          # Tools must be compiled for host, never inherit GOOS/GOARCH
          unset GOOS GOARCH GOBIN
          make controller-gen
      - name: Generate manifests and code
        run: |
          # Generate once (architecture-independent)
          unset GOOS GOARCH
          make manifests generate
      - name: Build binaries (validation only, no artifacts needed)
        run: |
          make V=1 GOOS=linux GOARCH=amd64 manager sidecar
          if [ ! -f "manager" ] || [ ! -f "sidecar" ]; then
            echo "ERROR: Build failed - binaries not found"
            ls -la
            exit 1
          fi
          echo "Build successful - binaries validated"

  scan-pr:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: build-binaries-pr
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v6
      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: .
          format: 'sarif'
          output: 'trivy-results.sarif'
          skip-dirs: vendor,node_modules,.git
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: trivy-results.sarif

  # ============================================
  # Main Workflow: Full release (multi-arch)
  # ============================================

  auto-tag:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: write
    concurrency:
      group: release-main
      cancel-in-progress: false
    outputs:
      tag: ${{ steps.increment.outputs.new_tag }}
      tag_created: ${{ steps.check_tag.outputs.exists == 'false' }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
      - name: Fetch all tags
        run: git fetch --tags --force
      - name: Get latest tag
        id: get_tag
        run: |
          TAG=$(git tag --list 'v*' --sort=-v:refname | head -n1 || echo "v0.0.0")
          if [ -z "$TAG" ] || [ "$TAG" = "" ]; then
            TAG="v0.0.0"
          fi
          echo "current_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Current tag: $TAG"
      - name: Increment version
        id: increment
        run: |
          CURRENT_TAG="${{ steps.get_tag.outputs.current_tag }}"
          VERSION="${CURRENT_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "New tag: $NEW_TAG"
      - name: Check if tag already exists
        id: check_tag
        run: |
          if git rev-parse "${{ steps.increment.outputs.new_tag }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag already exists, skipping"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
      - name: Create and push tag
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "${{ steps.increment.outputs.new_tag }}"
          git push origin "${{ steps.increment.outputs.new_tag }}" --verbose
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-binaries-main:
    runs-on: ${{ matrix.runner }}
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag_created == 'true'
    needs: auto-tag
    concurrency:
      group: build-${{ needs.auto-tag.outputs.tag }}-${{ matrix.platform }}
      cancel-in-progress: false
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
            goos: linux
            goarch: amd64
          - platform: linux/arm64
            runner: self-hosted
            goos: linux
            goarch: arm64
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV
      - uses: actions/setup-go@v6
        with:
          go-version: 1.25
      - name: Install build dependencies
        run: |
          # Tools must be compiled for host, never inherit GOOS/GOARCH
          unset GOOS GOARCH GOBIN
          make controller-gen
      - name: Generate manifests and code
        if: matrix.goarch == 'amd64'
        run: |
          # Generate once (architecture-independent) - only on amd64
          unset GOOS GOARCH
          make manifests generate
      - name: Build binaries
        run: |
          DATE=$(date -u +'%Y%m%d')
          SHA=$(git rev-parse --short HEAD)
          VERSION="${{ needs.auto-tag.outputs.tag }}"
          make V=1 GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} \
            DATE=$DATE SHA=$SHA VERSION=$VERSION \
            IMG_SIDECAR=${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar:${{ needs.auto-tag.outputs.tag }} \
            IMG_VALKEY=${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }} \
            manager sidecar
          if [ ! -f "manager" ] || [ ! -f "sidecar" ]; then
            echo "ERROR: Build failed - binaries not found"
            ls -la
            exit 1
          fi
          echo "Build successful for ${{ matrix.platform }}"
          ls -lh manager sidecar
      - name: Upload binaries
        uses: actions/upload-artifact@v6
        with:
          name: binaries-${{ env.PLATFORM_PAIR }}
          path: |
            manager
            sidecar
          retention-days: 1

  build-images:
    runs-on: ${{ matrix.runner }}
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag_created == 'true'
    needs: [auto-tag, build-binaries-main]
    concurrency:
      group: images-${{ needs.auto-tag.outputs.tag }}-${{ matrix.platform }}
      cancel-in-progress: false
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: self-hosted
    permissions:
      contents: read
      packages: write
    steps:
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV
          echo "RELEASE_VERSION=${{ needs.auto-tag.outputs.tag }}" >> $GITHUB_ENV
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Download binaries
        uses: actions/download-artifact@v7
        with:
          name: binaries-${{ env.PLATFORM_PAIR }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (Controller)
        id: meta_controller
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: ${{ env.RELEASE_VERSION }}
      - name: Extract metadata (Sidecar)
        id: meta_sidecar
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar
          tags: ${{ env.RELEASE_VERSION }}
      - name: Build and push Controller image
        id: docker_build_controller
        uses: docker/build-push-action@v6
        with:
          file: Dockerfile.controller
          context: .
          platforms: ${{ matrix.platform }}
          cache-from: type=gha
          # cache-to: type=gha,mode=max
          labels: ${{ steps.meta_controller.outputs.labels }}
          outputs: type=image,"name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}",push-by-digest=true,name-canonical=true,push=true
      - name: Build and push Sidecar image
        id: docker_build_sidecar
        uses: docker/build-push-action@v6
        with:
          file: Dockerfile.sidecar
          context: .
          platforms: ${{ matrix.platform }}
          cache-from: type=gha
          # cache-to: type=gha,mode=max
          labels: ${{ steps.meta_sidecar.outputs.labels }}
          outputs: type=image,"name=${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar",push-by-digest=true,name-canonical=true,push=true
      - name: Export digests (for manifest list creation)
        run: |
          mkdir -p ${{ runner.temp }}/digests/controller
          mkdir -p ${{ runner.temp }}/digests/sidecar

          # Obter digest do Controller (push-by-digest retorna o digest no output)
          CONTROLLER_DIGEST="${{ steps.docker_build_controller.outputs.digest }}"
          if [ -z "$CONTROLLER_DIGEST" ] || [ "$CONTROLLER_DIGEST" = "" ]; then
            echo "ERROR: Failed to get Controller digest from build output"
            exit 1
          fi
          echo "Controller digest (${{ matrix.platform }}): $CONTROLLER_DIGEST"
          touch "${{ runner.temp }}/digests/controller/${CONTROLLER_DIGEST#sha256:}"

          # Obter digest do Sidecar (push-by-digest retorna o digest no output)
          SIDECAR_DIGEST="${{ steps.docker_build_sidecar.outputs.digest }}"
          if [ -z "$SIDECAR_DIGEST" ] || [ "$SIDECAR_DIGEST" = "" ]; then
            echo "ERROR: Failed to get Sidecar digest from build output"
            exit 1
          fi
          echo "Sidecar digest (${{ matrix.platform }}): $SIDECAR_DIGEST"
          touch "${{ runner.temp }}/digests/sidecar/${SIDECAR_DIGEST#sha256:}"
      - name: Upload digests
        uses: actions/upload-artifact@v6
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: ${{ runner.temp }}/digests/*
          retention-days: 1

  merge-manifests:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag_created == 'true' && needs.auto-tag.outputs.tag != ''
    needs: [auto-tag, build-images]
    permissions:
      contents: read
      packages: write
    outputs:
      controller_manifest_digest: ${{ steps.get_manifest_digests.outputs.controller_manifest_digest }}
      sidecar_manifest_digest: ${{ steps.get_manifest_digests.outputs.sidecar_manifest_digest }}
      valkey_manifest_digest: ${{ steps.get_manifest_digests.outputs.valkey_manifest_digest }}
    steps:
      - name: Set RELEASE_VERSION
        run: |
          echo "RELEASE_VERSION=${{ needs.auto-tag.outputs.tag }}" >> $GITHUB_ENV
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: ${{ runner.temp }}/digests
          pattern: digests-*
          merge-multiple: true
      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Docker meta (Controller)
        id: meta_controller
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: ${{ env.RELEASE_VERSION }}
      - name: Create manifest list (Controller)
        id: create_manifest_controller
        working-directory: ${{ runner.temp }}/digests
        run: |
          cd controller
          OUTPUT=$(docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *) 2>&1)
          # Extract digest from output (format: "sha256:...")
          CONTROLLER_DIGEST=$(echo "$OUTPUT" | grep -oE 'sha256:[a-f0-9]{64}' | head -n1 || echo "")
          if [ -z "$CONTROLLER_DIGEST" ]; then
            echo "ERROR: Failed to extract Controller manifest digest from output"
            echo "Output: $OUTPUT"
            exit 1
          fi
          echo "controller_manifest_digest=$CONTROLLER_DIGEST" >> $GITHUB_OUTPUT
          echo "Controller manifest digest: $CONTROLLER_DIGEST"
      - name: Docker meta (Sidecar)
        id: meta_sidecar
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar
          tags: ${{ env.RELEASE_VERSION }}
      - name: Create manifest list (Sidecar)
        id: create_manifest_sidecar
        working-directory: ${{ runner.temp }}/digests
        run: |
          cd sidecar
          OUTPUT=$(docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar@sha256:%s ' *) 2>&1)
          # Extract digest from output (format: "sha256:...")
          SIDECAR_DIGEST=$(echo "$OUTPUT" | grep -oE 'sha256:[a-f0-9]{64}' | head -n1 || echo "")
          if [ -z "$SIDECAR_DIGEST" ]; then
            echo "ERROR: Failed to extract Sidecar manifest digest from output"
            echo "Output: $OUTPUT"
            exit 1
          fi
          echo "sidecar_manifest_digest=$SIDECAR_DIGEST" >> $GITHUB_OUTPUT
          echo "Sidecar manifest digest: $SIDECAR_DIGEST"
      - name: Docker meta (Valkey)
        id: meta_valkey
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey
          tags: ${{ env.VALKEY_VERSION }}
      - name: Get Valkey manifest list digest
        id: create_manifest_valkey
        run: |
          # Valkey is built in a separate workflow (valkey.yaml) which already creates the manifest list
          # We just need to get the digest of the existing manifest list
          echo "Getting Valkey manifest list digest from registry..."

          for i in {1..5}; do
            VALKEY_DIGEST=$(docker buildx imagetools inspect \
              ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }} \
              --format '{{json .}}' 2>/dev/null | jq -r '.manifest.digest // .digest // empty' || echo "")
            if [ -n "$VALKEY_DIGEST" ] && [ "$VALKEY_DIGEST" != "null" ] && [ "$VALKEY_DIGEST" != "" ]; then
              break
            fi
            echo "Attempt $i/5: Waiting for Valkey manifest list to be available..."
            sleep 2
          done

          if [ -z "$VALKEY_DIGEST" ] || [ "$VALKEY_DIGEST" = "null" ]; then
            echo "ERROR: Failed to get Valkey manifest list digest"
            echo "Note: Valkey manifest list should be created by valkey.yaml workflow"
            docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }} || true
            exit 1
          fi

          echo "valkey_manifest_digest=$VALKEY_DIGEST" >> $GITHUB_OUTPUT
          echo "Valkey manifest digest: $VALKEY_DIGEST"
      - name: Get manifest list digests
        id: get_manifest_digests
        run: |
          # Use digests captured from imagetools create
          CONTROLLER_MANIFEST_DIGEST="${{ steps.create_manifest_controller.outputs.controller_manifest_digest }}"
          SIDECAR_MANIFEST_DIGEST="${{ steps.create_manifest_sidecar.outputs.sidecar_manifest_digest }}"
          VALKEY_MANIFEST_DIGEST="${{ steps.create_manifest_valkey.outputs.valkey_manifest_digest }}"

          # Validate that digests were captured from create (they should always be)
          if [ -z "$CONTROLLER_MANIFEST_DIGEST" ] || [ "$CONTROLLER_MANIFEST_DIGEST" = "" ]; then
            echo "ERROR: Controller digest not captured from imagetools create"
            echo "This should not happen - check the create_manifest_controller step output"
            exit 1
          fi

          if [ -z "$SIDECAR_MANIFEST_DIGEST" ] || [ "$SIDECAR_MANIFEST_DIGEST" = "" ]; then
            echo "ERROR: Sidecar digest not captured from imagetools create"
            echo "This should not happen - check the create_manifest_sidecar step output"
            exit 1
          fi

          # Valkey manifest list should already exist from valkey.yaml workflow
          # Only use fallback for Valkey if digest wasn't captured
          if [ -z "$VALKEY_MANIFEST_DIGEST" ] || [ "$VALKEY_MANIFEST_DIGEST" = "" ]; then
            echo "Warning: Valkey digest not captured from create, using inspect..."
            for i in {1..5}; do
              VALKEY_MANIFEST_DIGEST=$(docker buildx imagetools inspect \
                ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }} \
                --format '{{json .}}' 2>/dev/null | jq -r '.manifest.digest // .digest // empty' || echo "")
              if [ -n "$VALKEY_MANIFEST_DIGEST" ] && [ "$VALKEY_MANIFEST_DIGEST" != "null" ]; then
                break
              fi
              echo "Attempt $i/5: Waiting for Valkey manifest list..."
              sleep 2
            done
          fi

          # Final validation
          if [ -z "$CONTROLLER_MANIFEST_DIGEST" ] || [ "$CONTROLLER_MANIFEST_DIGEST" = "null" ]; then
            echo "ERROR: Failed to get Controller manifest list digest"
            exit 1
          fi
          if [ -z "$SIDECAR_MANIFEST_DIGEST" ] || [ "$SIDECAR_MANIFEST_DIGEST" = "null" ]; then
            echo "ERROR: Failed to get Sidecar manifest list digest"
            exit 1
          fi
          if [ -z "$VALKEY_MANIFEST_DIGEST" ] || [ "$VALKEY_MANIFEST_DIGEST" = "null" ]; then
            echo "ERROR: Failed to get Valkey manifest list digest"
            exit 1
          fi

          echo "controller_manifest_digest=$CONTROLLER_MANIFEST_DIGEST" >> $GITHUB_OUTPUT
          echo "sidecar_manifest_digest=$SIDECAR_MANIFEST_DIGEST" >> $GITHUB_OUTPUT
          echo "valkey_manifest_digest=$VALKEY_MANIFEST_DIGEST" >> $GITHUB_OUTPUT
          echo "Controller manifest digest: $CONTROLLER_MANIFEST_DIGEST"
          echo "Sidecar manifest digest: $SIDECAR_MANIFEST_DIGEST"
          echo "Valkey manifest digest: $VALKEY_MANIFEST_DIGEST"
      - name: Inspect images
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.RELEASE_VERSION }}
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar:${{ env.RELEASE_VERSION }}
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }}

  sign-and-attest:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag_created == 'true' && needs.auto-tag.outputs.tag != ''
    needs: [auto-tag, merge-manifests]
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    steps:
      - name: Set RELEASE_VERSION
        run: |
          echo "RELEASE_VERSION=${{ needs.auto-tag.outputs.tag }}" >> $GITHUB_ENV
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set up Cosign
        uses: sigstore/cosign-installer@v3.7.0
      - name: Authenticate Cosign with GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Sign Controller manifest list
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.RELEASE_VERSION }}@${{ needs.merge-manifests.outputs.controller_manifest_digest }}
      - name: Sign Sidecar manifest list
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar:${{ env.RELEASE_VERSION }}@${{ needs.merge-manifests.outputs.sidecar_manifest_digest }}
      - name: Sign Valkey manifest list
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey:${{ env.VALKEY_VERSION }}@${{ needs.merge-manifests.outputs.valkey_manifest_digest }}
      - name: Attest Controller manifest list
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ needs.merge-manifests.outputs.controller_manifest_digest }}
          push-to-registry: true
      - name: Attest Sidecar manifest list
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey-sidecar
          subject-digest: ${{ needs.merge-manifests.outputs.sidecar_manifest_digest }}
          push-to-registry: true
      - name: Attest Valkey manifest list
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.REGISTRY }}/${{ github.repository_owner }}/valkey
          subject-digest: ${{ needs.merge-manifests.outputs.valkey_manifest_digest }}
          push-to-registry: true

  publish:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag_created == 'true' && needs.auto-tag.outputs.tag != ''
    needs: [auto-tag, sign-and-attest]
    permissions:
      contents: write
      packages: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Create release
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          if gh release view "$TAG" -R $GITHUB_REPOSITORY 2>/dev/null; then
            echo "Release $TAG already exists, skipping creation"
          else
            gh release create "$TAG" --title "Release $TAG" --generate-notes -R $GITHUB_REPOSITORY
          fi
        env:
          GH_TOKEN: ${{ github.token }}

  upload-assets:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag != ''
    needs: [auto-tag, publish]
    permissions:
      contents: write
      attestations: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v6
        with:
          go-version: 1.25
      - name: Build Installer
        run: make build-installer IMG=ghcr.io/${{ github.repository_owner }}/valkey-operator:${{ needs.auto-tag.outputs.tag }}
      - name: Attest
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: dist/install.yaml
      - name: Upload to release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: dist/install.yaml
          asset_name: install.yaml
          tag: ${{ needs.auto-tag.outputs.tag }}
          overwrite: true

  publish-helm:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.auto-tag.outputs.tag != ''
    needs: [auto-tag, publish]
    permissions:
      contents: write
      packages: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v6
        with:
          go-version: 1.25
      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Authenticate Helm
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io \
            -u ${{ github.actor }} \
            --password-stdin
      - name: Package and Upload Helm Chart
        env:
          REGISTRY_OWNER: ${{ github.repository_owner }}
        run: make helm-publish V=1 IMG=ghcr.io/${{ github.repository_owner }}/valkey-operator:${{ needs.auto-tag.outputs.tag }}
